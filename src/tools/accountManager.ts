/**
 * Account Manager for Algorand Remote MCP
 * Handles account-related operations on the Algorand blockchain
 */

import algosdk from 'algosdk';
import { z } from 'zod';
import { ResponseProcessor } from '../utils';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { Env, Props } from '../types';

/**
 * Register account management tools to the MCP server
 */
export function registerAccountTools(server: McpServer,env: Env, props: Props): void {
  // Create account tool
  server.tool(
    'create_algorand_keypair',
    'Create a new Algorand keypair! This is unrelated to account in wallet tools on this MCP! This is just an account generated by user request.',
    {},
    async () => {
      const account = algosdk.generateAccount();
      const mnemonic = algosdk.secretKeyToMnemonic(account.sk);
      
      return ResponseProcessor.processResponse({
        address: account.addr,
        mnemonic
      });
    }
  );
  
  // View address from mnemonic (without storing the private key)
  server.tool(
    'mnemonic_to_address',
    'View the Algorand address and secret key associated with a mnemonic ',
    { mnemonic: z.string().describe('Mnemonic phrase to view address and secrte key for') },
    async ({ mnemonic }) => {
      try {
        // This only derives the address from the mnemonic without storing the private key
        const sk = algosdk.mnemonicToSecretKey(mnemonic);
        
        return ResponseProcessor.processResponse({
          address: sk.addr,
          sk: Buffer.from(sk.sk).toString('hex'),
          message: 'This shows the address and sk associated with the mnemonic. For security reasons, the private key is not stored anywhere and solely for user external use purposes.'
        });
      } catch (error: any) {
        return {
          content: [{
            type: 'text',
            text: `Error deriving address from mnemonic: ${error.message || 'Unknown error'}`
          }]
        };
      }
    }
  );

  server.tool(
    'address_to_public_key',
    'View the Algorand public key associated with an Algorand address. returns the public key in hex format.',
    { address: z.string().describe('Address to get public key for') },
    async ({ address }) => {
      try {
       
        const pk = algosdk.decodeAddress(address);
        
        return ResponseProcessor.processResponse({
          publickey: Buffer.from(pk.publicKey).toString('hex'),
          message: 'This shows the public key associated with the given Algorand address.'
        });
      } catch (error: any) {
        return {
          content: [{
            type: 'text',
            text: `Error getting public key from address: ${error.message || 'Unknown error'}`
          }]
        };
      }
    }
  );
  
  // Check account balance
  server.tool(
    'check_account_balance',
    'Check the balance of an Algorand account',
    { address: z.string() },
    async ({ address }) => { 
      if (!env.ALGORAND_ALGOD) {
        return {
          content: [{
            type: 'text',
            text: 'Algorand node URL not configured'
          }]
        };
      }
      
      try {
        // Create algod client
        const algodClient = new algosdk.Algodv2(env.ALGORAND_TOKEN || '', env.ALGORAND_ALGOD, '');
        
        // Get account information
        const accountInfo = await algodClient.accountInformation(address).do();
        
        // Convert from microAlgos to Algos
        const balance = accountInfo.amount / 1000000;
        
        return ResponseProcessor.processResponse({
          address,
          balance,
          microAlgos: accountInfo.amount,
          minBalance: accountInfo['min-balance']
        });
      } catch (error: any) {
        return {
          content: [{
            type: 'text',
            text: `Error checking balance: ${error.message || 'Unknown error'}`
          }]
        };
      }
    }
  );
}
